import 'r'
import { v4 as uuidv4 } from 'uuid'; //will be used to generate unique identifiers for the messages
import { Server, StableBTreeMap, ic } from 'azle'; 
 // 'Server' class represents the server for the canister. Allows us to define and run the canister's HTTP server.
//  StableBTreeMap: a data structure that we'll use to store the messages. A map that associates keys with values, allowing us to store and retrieve messages within the canister.
// ic: This is an object that provides access to the Internet Computer's environment, including the ability to retrieve the current time.
import express from 'express'; // popular web framework for Node.js that we'll use to create a HTTP server.


// These dependencies will be crucial for building the messaging canister, 
// enabling us to generate unique identifiers, store messages, and create an HTTP 
// server for interacting with the canister.



/**
 * `messagesStorage` - it's a key-value datastructure that is used to store messages.
 * {@link StableBTreeMap} is a self-balancing tree that acts as a durable data storage that keeps data across canister upgrades.
 * For the sake of this contract we've chosen {@link StableBTreeMap} as a storage for the next reasons:
 * - `insert`, `get` and `remove` operations have a constant time complexity - O(1)
 * - data stored in the map survives canister upgrades unlike using HashMap where data is stored in the heap and it's lost after the canister is upgraded
 *
 * Brakedown of the `StableBTreeMap(string, Message)` datastructure:
 * - the key of map is a `messageId`
 * - the value in this map is a message itself `Message` that is related to a given key (`messageId`)
 *
 * Constructor values:
 * 1) 0 - memory id where to initialize a map.
 */


/**
 * 1. defining message type
    This type represents a message that can be listed on a board.
    Defining the structure of the data we'll be working with
*/
class Message {
    id: string;
    title: string;
    body: string;
    attachmentURL: string;
    createdAt: Date;
    updatedAt: Date | null
 }

 /** 
  * 2. Defining message storage
  * this map will store our messages, associating each message with a unique identifier.
  *  
 */

 const messagesStorage = StableBTreeMap<string, Message>(0);
 /**
  * StableBTreeMap: This is the class that represents the stable B-tree map data structure. It's used to store and retrieve data within the canister.
  * <string, Message>: This specifies the types of the keys and values in our map. In this case, the keys are strings (the unique identifiers of our messages), and the values are of type Message.
  * (0): This is the ID of the stable memory region where the map will be stored. Used to ensure that the map persists across canister redeployments.
  */
 
 /**
  * 3. Creating the server
  *  create an HTTP server that will handle requests to the canister. 
  * Server will be responsible for processing incoming requests and returning appropriate responses.
  */

 export default Server(() => {
    const app = express();
    app.use(express.json());

/**
 * initialize the server by calling Server.
 * function takes a callback that returns an instance of the 'express' app.
 * create an instance of the app and use the 'express.json' middleware 
 * to parse incoming requests with JSON payloads
 *  
*/ 

/**
 * 4. Creating the add message function
 */

    app.post("/messages", (req, res) => {  //sets up a route for POST requests to the '/messages' endpoint. It takes a callback function that receives the request (req) and response (res) objects.
        const message: Message =  {id: uuidv4(), createdAt: getCurrentDate(), ...req.body};
        // creates a new message object by combining the unique identifier generated 
        // by uuidv4(), the current date and time, and the data sent in the request body 
        // (req.body). The ... syntax is the spread operator, which allows us to merge the 
        // properties of req.body into the new message object.
        messagesStorage.insert(message.id, message); //inserts the new message into our' messagesStorage' map, associating it with the unique identifier generated by 'uuidv4()'.
        res.json(message); //  sends a JSON response containing the newly created message back to the client.
    });


 /**
  * 5. Creating the get messages function
  * involves creating a function to retrieve all messages that have been added to our canister.
  */

    app.get("/messages", (req, res) => {
        res.json(messagesStorage.values());
    });

 /**
  * sets up a route for GET requests to the /messages endpoint and sends a 
  * JSON response containing all the messages stored in our messagesStorage 
  * This function, therefore, allows us to retrieve all messages that have been added to 
  * our canister. We call the values method on our messagesStorage map to retrieve all 
  * the messages it contains. This method returns an array of all the values in the map, 
  * which we then send back to the client as a JSON response.
  */



 /**
  * 6. Creating the Get message function
  * create a function that allows us to retrieve a specific message by its unique identifier.
  * 
  * This function sets up a route for GET requests to the /messages/:id endpoint, where 
  * :id is a route parameter representing the unique identifier of the message to be retrieved.
  */


    
    app.get("/messages/:id", (req, res) => { //this line sets up a route for GET requests to the /messages/:id endpoint. Takes a callback function that receives the request (req) and response (res) objects.
        const messageId = req.params.id; //retrieves the unique identifier of the message from the route parameters.
        const messageOpt = messagesStorage.get(messageId); //retrieves the message from our messagesStorage map by its unique identifier. 
        // The get method returns an Opt type, which represents the possibility of a value being present (Some) or absent (None).
        if ("None" in messageOpt) {
            //   checks if the message was found in the messagesStorage map. 
            // If not, send a 404 status code and a message indicating that the message with the provided ID was not found.
        res.status(404).send(`the message with id=${messageId} not found`);
        } else {
        res.json(messageOpt.Some); //ends a JSON response containing the retrieved message back to the client.
        }
    });


 /**
  * 7. Developing the update message function
  *  create a function that allows us to update an existing message. 
  * 
  * This function sets up a route for PUT requests to the /messages/:id 
  * in order to update a specific message by its unique identifier.
  */


app.put("/messages/:id", (req, res) => { //sets up a route for PUT requests to the /messages/:id endpoint. It takes a callback function that receives the request (req) and response (res) objects.
    const messageId = req.params.id; //retrieves the unique identifier of the message from the route parameters.
    const messageOpt = messagesStorage.get(messageId);
    // retrieves the message from our messagesStorage map by its unique identifier. 
    // The get method returns an Opt type, which represents the possibility of a value 
    // being present (Some) or absent (None).
    if ("None" in messageOpt) {
        //checks if the message was found in the messagesStorage map. 
        // If not, send a 400 status code and a message indicating that the message with the provided ID was not found.
       res.status(400).send(`couldn't update a message with id=${messageId}. message not found`);
    } else {
       const message = messageOpt.Some; //retrieves the message from the messageOpt object.
    //creates an updated message by merging the existing message with the data sent in 
    // the request body (req.body) and adding the current date and time as the updatedAt 
    // property. The ... syntax is the spread operator, which allows us to merge the 
    // properties of req.body into the existing message.
       const updatedMessage = { ...message, ...req.body, updatedAt: getCurrentDate()};
       messagesStorage.insert(message.id, updatedMessage);  //inserts the updated message into the messagesStorage map, associating it with the unique identifier of the original message.
       res.json(updatedMessage);  //sends a JSON response containing the updated message back to the client.
    }
 });


 /**
  * 8. Creating a function to delete a message
  * FINAL STEP:
  * create a function that allows for message deletion. 
  */
0.
 
app.delete("/messages/:id", (req, res) => {
    // function sets up a route for DELETE requests to the /messages/:id endpoint in 
    // order to delete a specific message by its unique identifier
    const messageId = req.params.id;
    const deletedMessage = messagesStorage.remove(messageId);
    // use the remove method on our messagesStorage map to delete the message with the 
    // provided ID. This method returns an Opt type, which represents the possibility of
    //  a value being present (Some) or absent (None).
    if ("None" in deletedMessage) {
        // If message was found and deleted,send a JSON response containing the deleted 
        // message back to the client. If the message not found, send a 400 status code 
        // and a message indicating that the message with the provided ID was not found.
       res.status(400).send(`couldn't delete a message with id=${messageId}. message not found`);
    } else {
       res.json(deletedMessage.Some);
    }
 });


 /**
  * 9. in order to allow our server to listen for incoming requests:
  */

return app.listen();
}); // to close the Server function.


/**
 * Get Current Date Function
 * 
 * function will be defined outside the Server function.
 * retrieves the current time from the Internet Computer environment using the ic.time() 
 * method. It then converts the timestamp to a JavaScript Date object and returns it. 
 * This function will be used to set the createdAt and updatedAt properties of our messages.
 * 
 */

function getCurrentDate() {
    const timestamp = new Number(ic.time());
    return new Date(timestamp.valueOf() / 1000_000);
}

// http://localhost:34551/_/dashboard


// filter cruel team oven grain shuffle exchange space method pole enact skull moral blind miracle ordinary nest expose worry awkward power cream doctor pool